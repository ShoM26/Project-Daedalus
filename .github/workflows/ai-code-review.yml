name: AI Code Review

on:
  pull_request:
    types: [opened, synchronize]
    paths:
      - '**.cs'
      - '**.js'
      - '**.jsx'
      - '**.ino'
      - '**.css'

permissions:
  pull-requests: write
  contents: read

jobs:
  ai-review:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get PR diff
        id: diff
        run: |
          # Get the diff for this PR with file context
          git fetch origin ${{ github.base_ref }}
          
          # Get detailed diff with file names and line numbers
          git diff -U3 origin/${{ github.base_ref }}...HEAD > pr_diff.txt
          
          # Also get list of changed files
          git diff --name-only origin/${{ github.base_ref }}...HEAD > changed_files.txt
          
          # Check if diff is empty
          DIFF_SIZE=$(wc -c < pr_diff.txt)
          echo "diff_size=$DIFF_SIZE" >> $GITHUB_OUTPUT
          
          if [ $DIFF_SIZE -eq 0 ]; then
            echo "skip=true" >> $GITHUB_OUTPUT
          else
            echo "skip=false" >> $GITHUB_OUTPUT
          fi

      - name: Check diff size
        if: ${{ steps.diff.outputs.diff_size > 50000 }}
        run: |
          echo "::warning::Diff too large for AI review (>50KB). Skipping."
          exit 0

      - name: AI Code Review
        if: ${{ steps.diff.outputs.skip != 'true' }}
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
          REPO: ${{ github.repository }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Read the diff
          DIFF=$(cat pr_diff.txt)
          CHANGED_FILES=$(cat changed_files.txt)
          
          # Escape the diff for JSON
          DIFF_ESCAPED=$(echo "$DIFF" | jq -Rs .)
          
          # Create the prompt for inline comments
          PROMPT="You are an expert code reviewer. Analyze the following git diff and provide specific, actionable feedback.

          CRITICAL: Your response must be ONLY a valid JSON array. Do not include any markdown, explanations, or text outside the JSON array.

          Format: Return a JSON array where each element has:
          - \"path\": the file path (string)
          - \"line\": the line number in the new file after changes (number)
          - \"body\": your review comment (string)

          Rules:
          1. Only comment on actual issues (bugs, security, performance, best practices)
          2. If the code is good, return an empty array: []
          3. Line numbers must be lines that were ADDED (lines starting with + in the diff)
          4. Your entire response must be valid JSON - no extra text
          5. Keep comments professional and constructive

          Example response:
          [
            {
              \"path\": \"src/app.js\",
              \"line\": 15,
              \"body\": \"Consider adding null check here to prevent potential runtime error.\"
            }
          ]

          Changed files:
          $CHANGED_FILES

          Git diff:
          $DIFF"
          
          # Escape prompt for JSON
          PROMPT_ESCAPED=$(echo "$PROMPT" | jq -Rs .)
          
          # Call Gemini API
          echo "Calling Gemini API..."
          RESPONSE=$(curl -s -X POST \
            "https://generativelanguage.googleapis.com/v1/models/gemini-2.5-pro:generateContent?key=$GEMINI_API_KEY" \
            -H "Content-Type: application/json" \
            -d "{
              \"contents\": [{
                \"parts\": [{
                  \"text\": $PROMPT_ESCAPED
                }]
              }],
              \"generationConfig\": {
                \"temperature\": 0.3,
                \"maxOutputTokens\": 8192
              }
            }")
          
          # Check for errors
          ERROR=$(echo "$RESPONSE" | jq -r '.error.message // empty')
          
          if [ ! -z "$ERROR" ]; then
            echo "API Error: $ERROR"
            echo "Full response: $RESPONSE"
            
            # Post error as comment instead of failing
            ERROR_MSG="AI Code Review Failed\n\nAPI Error: $ERROR\n\nPlease check the workflow logs."
            ERROR_ESCAPED=$(echo "$ERROR_MSG" | jq -Rs .)
            
            curl -s -X POST \
              -H "Authorization: token $GITHUB_TOKEN" \
              -H "Accept: application/vnd.github.v3+json" \
              "https://api.github.com/repos/$REPO/issues/$PR_NUMBER/comments" \
              -d "{\"body\": $ERROR_ESCAPED}"
            
            exit 0
          fi
          
          echo "Successfully received response from Gemini"
          
          # Debug: Print full response structure
          echo "=== Full API Response ==="
          echo "$RESPONSE" | jq '.'
          echo "========================"
          
          # Extract the review text - handle different response structures
          REVIEW=$(echo "$RESPONSE" | jq -r '.candidates[0].content.parts[0].text // empty')
          
          if [ -z "$REVIEW" ]; then
            echo "Could not extract text from standard location, trying alternatives..."
            # Try alternative paths
            REVIEW=$(echo "$RESPONSE" | jq -r '.candidates[0].text // empty')
            
            if [ -z "$REVIEW" ]; then
              REVIEW=$(echo "$RESPONSE" | jq -r '.text // empty')
            fi
            
            if [ -z "$REVIEW" ]; then
              echo "Error: Could not find review text in response"
              echo "Response structure:"
              echo "$RESPONSE" | jq 'keys'
              
              # Post error and exit
              ERROR_MSG="AI Code Review Failed\n\nCould not extract review from Gemini response. Check workflow logs for details."
              ERROR_ESCAPED=$(echo "$ERROR_MSG" | jq -Rs .)
              
              curl -s -X POST \
                -H "Authorization: token $GITHUB_TOKEN" \
                -H "Accept: application/vnd.github.v3+json" \
                "https://api.github.com/repos/$REPO/issues/$PR_NUMBER/comments" \
                -d "{\"body\": $ERROR_ESCAPED}"
              
              exit 0
            fi
          fi
          
          echo "Successfully extracted review text"
          
          # Save the raw review
          echo "$REVIEW" > review_raw.txt
          echo "=== Raw Review Content ==="
          cat review_raw.txt
          echo ""
          echo "=========================="
          
          # Check if response was truncated
          FINISH_REASON=$(echo "$RESPONSE" | jq -r '.candidates[0].finishReason // "UNKNOWN"')
          echo "Finish reason: $FINISH_REASON"
          
          if [ "$FINISH_REASON" == "MAX_TOKENS" ]; then
            echo "WARNING: Response was truncated due to token limit. Attempting to salvage partial JSON..."
          fi
          
          # Remove markdown code fences first
          REVIEW_CLEAN=$(echo "$REVIEW" | sed 's/```json//g' | sed 's/```//g')
          
          # Extract JSON from the response - try multiple methods
          echo "Attempting to extract JSON..."
          
          # Method 1: Direct JSON parse if entire response is valid JSON
          if echo "$REVIEW_CLEAN" | jq empty 2>/dev/null; then
            COMMENTS=$(echo "$REVIEW_CLEAN" | jq -c '.')
            echo "Method 1 success: Entire response is valid JSON"
          else
            # Method 2: Try to fix incomplete JSON by finding last complete object
            # Find the start of the array
            COMMENTS=$(echo "$REVIEW_CLEAN" | grep -ozP '\[[\s\S]*' | tr -d '\0')
            
            # If we have an opening bracket, try to close it properly
            if [[ "$COMMENTS" == "["* ]]; then
              # Remove any incomplete last object (anything after the last complete })
              COMMENTS=$(echo "$COMMENTS" | sed 's/,[^}]*$//')
              
              # Make sure it ends with ]
              if [[ "$COMMENTS" != *"]" ]]; then
                COMMENTS="${COMMENTS}]"
              fi
              
              # Validate
              if echo "$COMMENTS" | jq empty 2>/dev/null; then
                echo "Method 2 success: Fixed incomplete JSON"
                COMMENTS=$(echo "$COMMENTS" | jq -c '.')
              else
                echo "Method 2 failed: Could not fix incomplete JSON"
                
                # Method 3: Extract only complete objects
                # Find all complete JSON objects between { and }
                TEMP_COMMENTS="["
                while IFS= read -r line; do
                  OBJ=$(echo "$line" | grep -oP '\{[^}]*\}')
                  if [ ! -z "$OBJ" ] && echo "$OBJ" | jq empty 2>/dev/null; then
                    if [ "$TEMP_COMMENTS" != "[" ]; then
                      TEMP_COMMENTS="${TEMP_COMMENTS},"
                    fi
                    TEMP_COMMENTS="${TEMP_COMMENTS}${OBJ}"
                  fi
                done <<< "$REVIEW_CLEAN"
                TEMP_COMMENTS="${TEMP_COMMENTS}]"
                
                if echo "$TEMP_COMMENTS" | jq empty 2>/dev/null && [ "$TEMP_COMMENTS" != "[]" ]; then
                  echo "Method 3 success: Extracted complete objects only"
                  COMMENTS=$(echo "$TEMP_COMMENTS" | jq -c '.')
                else
                  echo "All extraction methods failed"
                  COMMENTS=""
                fi
              fi
            else
              echo "Could not find JSON array start"
              COMMENTS=""
            fi
          fi
          
          echo "Final extracted comments: $COMMENTS"
          
          # Check if we got valid JSON array
          if [ -z "$COMMENTS" ] || [ "$COMMENTS" == "null" ] || [ "$COMMENTS" == "[]" ]; then
            echo "No inline comments to post (empty or invalid JSON)"
            # Post a general comment instead
            SUMMARY="Code review completed. No specific issues found."
            SUMMARY_ESCAPED=$(echo "$SUMMARY" | jq -Rs .)
            
            curl -s -X POST \
              -H "Authorization: token $GITHUB_TOKEN" \
              -H "Accept: application/vnd.github.v3+json" \
              "https://api.github.com/repos/$REPO/issues/$PR_NUMBER/comments" \
              -d "{\"body\": $SUMMARY_ESCAPED}"
          else
            # Get the latest commit SHA
            COMMIT_SHA=$(git rev-parse HEAD)
            
            # Build the review comments array for GitHub API
            # Process all comments at once instead of in a loop
            REVIEW_COMMENTS=$(echo "$COMMENTS" | jq -c '[.[] | {
              path: .path,
              line: (.line | tonumber),
              side: "RIGHT",
              body: .body
            } | select(.path != null and .line != null and .body != null)]')
            
            # Verify files exist in the PR
            VALID_COMMENTS="[]"
            COMMENT_COUNT=$(echo "$REVIEW_COMMENTS" | jq 'length')
            
            echo "Processing $COMMENT_COUNT comments..."
            
            for i in $(seq 0 $(($COMMENT_COUNT - 1))); do
              PATH_FILE=$(echo "$REVIEW_COMMENTS" | jq -r ".[$i].path")
              
              if grep -Fxq "$PATH_FILE" changed_files.txt; then
                COMMENT=$(echo "$REVIEW_COMMENTS" | jq -c ".[$i]")
                VALID_COMMENTS=$(echo "$VALID_COMMENTS" | jq -c ". += [$COMMENT]")
                echo "  ✓ $PATH_FILE"
              else
                echo "  ✗ Skipping $PATH_FILE (not in changed files)"
              fi
            done
            
            echo "Valid comments: $(echo "$VALID_COMMENTS" | jq 'length')"
            
            if [ "$REVIEW_COMMENTS" == "[]" ]; then
              echo "No valid comments to post"
              exit 0
            fi
            
            # Create a review with inline comments
            REVIEW_BODY=$(jq -n \
              --arg commit_id "$COMMIT_SHA" \
              --argjson comments "$REVIEW_COMMENTS" \
              --arg event "COMMENT" \
              --arg body "AI Code Review" \
              '{
                commit_id: $commit_id,
                body: $body,
                event: $event,
                comments: $comments
              }')
            
            echo "Posting review with inline comments..."
            
            REVIEW_RESPONSE=$(curl -s -X POST \
              -H "Authorization: token $GITHUB_TOKEN" \
              -H "Accept: application/vnd.github+json" \
              -H "X-GitHub-Api-Version: 2022-11-28" \
              "https://api.github.com/repos/$REPO/pulls/$PR_NUMBER/reviews" \
              -d "$REVIEW_BODY")
            
            echo "Review response: $REVIEW_RESPONSE"
            
            # Check if review was created successfully
            REVIEW_ID=$(echo "$REVIEW_RESPONSE" | jq -r '.id // empty')
            
            if [ -z "$REVIEW_ID" ]; then
              echo "Failed to create review. Response:"
              echo "$REVIEW_RESPONSE" | jq '.'
              
              # Fallback: post as general comment
              FALLBACK_BODY="AI Code Review\n\nAttempted to post inline comments but encountered an error. Here are the findings:\n\n"
              echo "$COMMENTS" | jq -r '.[] | "**\(.path):\(.line)** - \(.body)\n"' >> fallback.txt
              FALLBACK_FULL=$(cat fallback.txt)
              FALLBACK_ESCAPED=$(echo "$FALLBACK_FULL" | jq -Rs .)
              
              curl -s -X POST \
                -H "Authorization: token $GITHUB_TOKEN" \
                -H "Accept: application/vnd.github.v3+json" \
                "https://api.github.com/repos/$REPO/issues/$PR_NUMBER/comments" \
                -d "{\"body\": $FALLBACK_ESCAPED}"
            else
              echo "Review created successfully with ID: $REVIEW_ID"
            fi
          fi

      - name: Summary
        if: ${{ steps.diff.outputs.skip != 'true' }}
        run: |
          echo "AI code review completed for PR #${{ github.event.pull_request.number }}"